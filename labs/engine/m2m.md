Какой смысл в целом выводке архитектурных паттернов вроде MVC, MVVM, MVP, MVD?

Что, например, представляет из себя V (View) применительно к веб-приложению?
Это - DOM (Document Object Model). Ключевое слово здесь - model. Отличается ли
от этого подход в других фреймворках, начиная от олдскульных Turbo Vision или
VCL до современных WPF, UIKit или Android? Нет. Это такие же программные модели,
как и любые другие. Просто в этой области мы говорим на диалекте дизайнеров
пользовательских интерфейсов. В терминах кнопок, форм и т.п. Та Model, к
которой привыкли разработчики приложений, для БД-инженера - View.

Как выглядит C (Controller) в типичных же веб-приложениях? Модель DOM-события,
вместе с данными DOM-моделей для форм транслируется в некоторую внутреннюю
модель. Что такое VM (View-Model)? Это такая же трансформация, которая обычно
называется "binder". Такую же роль играет и P (Presenter) или D (Dispatcher).

Какую реальную помощь все эти знания могут оказать мне при создании приложения?
Это же архитектурный паттерн. Возьму, скажем, веб-решение средней сложности с
SPA-клиентом. Хорошо, если у меня тонкий клиент на чистом MVC вроде старого
AngularJS. Но велика вероятность, что это уже React. И вот появились ярко
выраженные VM (Virtual DOM), а за ними Redux с actions, reducers и stores. Всё
это дополняется коммуникационным слоем со своими request/response-моделями,
различными (де)сериализаторами. И я ещё не покинул браузер.

Может быть у меня хотя бы на сервере ярко выраженный MVC? Но скорее всего нет.
Полученная информация трансформируется в message models и отправляется в очередь
сообщений. Соответствующие обработчики на доли секунды трансформируют их в то,
что мы могли бы счесть моделями и тут же они распадутся на различные DTO, entity
models и т.п.

Теперь стоит вспомнить, что решение - это не одно приложение. Могут быть тесты,
CLI, системы документирования, генерации. И каждый из них готов претендовать на
архитектурный паттер своего имени. Скажем тесты могут потребовать себе SAC (Sample-Action-Constraint).

Что я получаю в итоге? Практически все архитектуры несут в себе M (Model) и V
(View), которое обладает всеми признаками M для отдельной группы участников
производственного процесса. То, что бэкенждеру кажется Model, для БД-инженера
станет View. Все остальные "символы" в той или иной форме описывают
трансформацию между моделями.

Одно приложение может содержать смесь самых разных "символов" из самых разных
подходов. Взяв какой-то отдельный паттерн я не выстрою архитектуру приложения,
повезёт если маленький его участок.

Так может всё упростить до концепции M2M/MTM (Model-to-Model), постепенно
обогащая её библиотекой модельных слоёв, трансформаций и готовых решений? Это
совершенно логичное применение принципов удачного дизайна вроде SOLID к таким
монолитным конструкциям как рассматриваемые MV\*-паттерны (достаточно посмотреть
на попытки сообщества найти их в том же React+Redux).

Каждая такая трансформация легко тестируется, повторно используется и
расширяется. Архитектура плетётся из гибкой mesh-конструкции, а не строится на
колоссе с тремя глиняными ножками. Любые новые архитектурные идеи (например,
Redux) могут безболезненно интегрироваться в существующие шаблоны. В том числе,
такой подход без труда абсорбирует и все существующие MV\*-паттерны.

Я больше не буду заложником предопределённого числа слоев и могу с легкостью
обозначить на диаграмме и базу данных и очередь сообщений и Redux stores.
Долой вопросы, почему VM-трансформация существует, а DTO-нет. И, главное, легче
будет выбрать архитектуру реального приложения под заданные задачи, чем
опираться на в высшей мере абстрактные MV\*-конепции.

	todo Провести эксперимент с https://medium.freecodecamp.org/lets-experiment-with-functional-generators-and-the-pipeline-operator-in-javascript-520364f97448
