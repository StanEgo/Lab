using System.Runtime.CompilerServices;

/// <summary>
/// TODO:
/// </summary>
/// 
/// <remarks>
/// TODO:Application should start from specification phase
/// TODO:Specifications should be as much executable as they can (extract
/// extended DevOps principle of SDD.NET to README.md, so the primary focus is
/// not an application itself, it is automating developers tasks, considering
/// their activity as a target for automation not a framework).
///
/// <para>
/// TODO: This Specification assembly is an application's layer (additionally
/// to Design, Infrastructure, CLI and others). Most of them can be represented
/// in SDD itself as a sample of solution framework.
/// </para>
/// 
/// <para>
/// TODO: Assembly (the layer) should be considered as a combination of
/// different domains. So SomeApp.Specification assembly can contain all docs,
/// samples, tests, etc. That would be good for documentation as well, because
/// this assembly may contains references to any others. That is much better
/// than reference samples from core objects. So documentation is build based
/// on specification. But specification can reference other assemblies and
/// reuse documentation from them. For example, some interfaces.
/// </para>
/// 
/// <para>
/// TODO:So the first step of any application is to create MyApp.Specification
/// assembly. It will contain all we know about application.
/// 
/// TODO: I'll use SDD as a recursive sample. So it's idea will be implemented
/// for it's design.
/// 
/// TODO:When analyzing stakeholders' requirements we'll start from samples.
/// In this sample class we will describe all/ we know about particular entity.
/// 
/// TODO: Then we can extract some specific contracts from such samples and
/// start to put it into SDD.Frame/SDD.Design.
/// </para>
/// </remarks>
[CompilerGenerated]
internal class AssemblyDoc
{

}
