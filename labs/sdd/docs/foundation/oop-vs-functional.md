## Inbox
* Обычно, столпами ООП считается: абстрагирование, инкапсуляция, наследование и
  полиморфизм. У меня есть масса сомнений в оправданности этой идеи в целом:
  * Наследование - вызывает вопросы, поскольку языки, основанные на
    прототипировании являются не менее объектно-ориентированными. Это просто
	один из способов для повторного использования имеющегося кода. С
	аналогичным успехом я могу в динамических языках просто скопировать
	реализации.
  * Полиморфизм - тоже странный критерий. Если у меня есть некоторый контракт,
    за которым может стоять какая угодно реализация (структура C с
	полями-функциями, запись Rust реализациями traits или что-то другое). Это
	просто концепция правильного дизайна - разделение интерфейсов и реализаций.
  * Инкапсуляция и абстрагирование - За счёт первого существенно ухудшается
    второе.
* Фактически, единственное преимущество ООП - это возможность вызова
  object.Method(). Что является скорее синтаксическим сахаром и с легкостью
  демонстрируется как method extensions в .NET или trait/impl в Rust.
* Контроль видимости (private/protected) тоже вызываем множество вопросов.
  В той части, где он обеспечивает полиморфизм, преимущества теряются вместе с
  самим полиморфизмом. Защищенные поля в структурах, предназначенные зачастую
  для хранения каких-то промежуточных результатов (окончательные результаты по
  определению не могут быть защищены от потребителя) лишь раздувают потребление
  памяти, поскольку используются временно, а аллоцируются постоянно.
