Данное руководство является практичным. Следуя ему SDD Team создаёт конечный
продукт (SDD Team Server) выступая в роли одного из заказчиков.

## Спецификация
Первый этап разработки - это сбор требований. Даже если это виртуальное
интервьюирование самого себя, следующее за озарением идеей стартапа. Требование
- суть ответ на вопрос "что оно должно делать".

Привычный артефакт по результатам сбора - интервьюер что-то понимает и у него
хаотические заметки. Если заглянуть чуть вперёд, то за этим этапом следует
формализация собранных данных в спецификацию, за которой следует очередная
трансляция спецификации в код классов, тестов и т.п. Из спецификации зачастую
требуется сформировать и поддерживать документацию. Как результат - частые
потери информации до попадания в спецификацию, отставание документации от
реального положения дел и в целом очень много издержек.

Чтобы их сократить, стоит рассмотреть Specification-as-a-code в рамках парадигмы
as-a-Code. Во многом она является синонимом бытующего подхода executable
specifications (Gherkin, Cucumber, Specflow и т.п.). Тот язык, на котором мы
фиксируем результаты интервью, должен быть максимально приближен к языку
разработки и максимально удобен для ведения интервью
[[Gherkin way]](../guidelet/gherkin-way)
TODO:Отправить в Foundation?

Практически процесс может выглядеть следующим образом. В выбранной экосистеме
(на примере .NET) создаем приложение SDD.Specification (SDD.Specs, ...). В нём
начинаем структурировать предметную область через папки/namespaces в привычном
стиле, но за тем исключением, что в отдельно взятом файле мы можем описывать все
слои приложения: модели, БД-маппинги, UI-формы и т.п. Данная сборка не идёт в
production, поэтому этот аспект нас не волнует. На этом этапе важно видеть всю
картину, как в документации, чем она и является.

По мере того как рафинируются классы, методы, интерфейсы и т.п., они постепенно
выделяются в соответствующие сборки и specs уже ссылается на них.

TODO:Всю теорию отсюда надо выносить в foundation. Здесь - процесс создания.
TODO:Первые эксперименты можно провести на Rust, всё-таки его макросы могут дать
определённую выгоду и скорость тоже немаловажна. Или сразу давать в сравнении
Rust/TypeScript/F#/C# в режиме "гонки", кто будет вырываться в лидеры?
TODO:В качестве требований должен использоваться vision. Начинать можно с
описания в некотором условном main.rs.
TODO:Текст интервью можно кидать прямо в код. Пусть в условной ветке Git
interview/
TODO:Ubiquitous language - сборка Specs, это оно и есть.
TODO:CLI для интервьюера, может по аналогии Providers в Powershell. Може удастся
описывать действия его командами и тогда он может создавать артефакты на разных
языках.
TODO:MVP становится практически естественным "выхлопом" процесса. Система
практически постоянно генерирует некоторый MVP основываясь на требованиях и
только лишь их ошибочность (TDD) препятствует этому.
TODO:Может не существовать бойлеплейта для приложения (скажем, готовые сборки
Core/Infrastructure/Web). CLI может автоматически собирать классы, интерфейсы и
т.п. согласно conventions и добавлять их в соответствующие сборки (создавая при
отсутствии).
