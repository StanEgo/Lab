Данное руководство является практичным. Следуя ему SDD Team создаёт конечный
продукт (SDD Team Server) выступая в роли одного из заказчиков.

## Спецификация
Первый этап разработки - это сбор требований. Даже если это виртуальное
интервьюирование самого себя, следующее за озарением идеей стартапа. Требование
- суть ответ на вопрос "что оно должно делать".

Привычный артефакт по результатам сбора - интервьюер что-то понимает и у него
хаотические заметки. Если заглянуть чуть вперёд, то за этим этапом следует
формализация собранных данных в спецификацию, за которой следует очередная
трансляция спецификации в код классов, тестов и т.п. Из спецификации зачастую
требуется сформировать и поддерживать документацию. Как результат - частые
потери информации до попадания в спецификацию, отставание документации от
реального положения дел и в целом очень много издержек.

Чтобы их сократить, стоит рассмотреть спецификацию в рамках парадигмы as-a-Code
- Specification-as-a-code. Во многом она является синонимом бытующего подхода
executable specifications (Gherkin, Cucumber, Specflow и т.п.). Тот язык, на
котором мы фиксируем результаты интервью, должен быть максимально приближен к
языку разработки и максимально удобен для ведения интервью.

Практически процесс может выглядеть следующим образом. В выбранной экосистеме
(на примере .NET) создаем приложение SDD.Specification (SDD.Specs, ...). В нём
начинаем структурировать предметную область через папки/namespaces в привычном
стиле, но за тем исключением, что в отдельно взятом файле мы можем описывать все
слои приложения: модели, БД-маппинги, UI-формы и т.п. Данная сборка не идёт в
production, поэтому этот аспект нас не волнует. На этом этапе важно видеть всю
картину, как в документации, чем она и является.

По мере того как рафинируются классы, методы, интерфейсы и т.п., они постепенно
выделяются в соответствующие сборки и specs уже ссылается на них.

TODO:Всю теорию отсюда надо выносить в foundation. Здесь - процесс создания.
TODO:Первые эксперименты можно провести на Rust, всё-таки его макросы могут дать
определённую выгоду и скорость тоже немаловажна. Или сразу давать в сравнении
Rust/TypeScript/F#/C# в режиме "гонки", кто будет вырываться в лидеры?
TODO:В качестве требований должен использоваться vision. Начинать можно с
описания в некотором условном main.rs.
TODO:Текст интервью можно кидать прямо в код. Пусть в условной ветке Git
interview/
TODO:Ubiquitous language - сборка Specs, это оно и есть.
TODO:CLI для интервьюера, может по аналогии Providers в Powershell. Може удастся
описывать действия его командами и тогда он может создавать артефакты на разных
языках.
TODO:MVP становится практически естественным "выхлопом" процесса. Система
практически постоянно генерирует некоторый MVP основываясь на требованиях и
только лишь их ошибочность (TDD) препятствует этому.
TODO:Gherkin - это не совсем удачный компромис (отдельная статья про Gherkin way).
Да, он частично удовлетворяет и разработчика и заказчика, но другая сторона этой
медали - он не является удачным инструментом ни для того, ни для другого.
Gherkin очень рудиментарен и практически не расширяем. Нет возможности описывать
типы (а ADT в функциональных языках могут определять логику валидации), слабая
возможность структурирования, повторного использования. Для разработчика это
лишь дополнительный слой трансляции. Бытовала гипотеза, что заказчик сможет
писать сразу на нём. Кто-нибудь видел такое? И здесь опять возникает проблема с
тем, что Gherkin описывает предметную область однобоко.
Альтернативный вариант - язык, максимально близкий к используемому языку
программирования, что даёт формальность и гибкость. Организованный для
максимально удобного использования интервьюером и активно эксплуатирующий
генеративную идею. В идеале, до достижения согласованности всех требований, он
выдает TDD Red и соответствующий отчёт. Как только возникает TDD Green, 
формируется MVP приложения. Да, это могут быть не самые эффективные структуры БД
и не самые удачные формы пользовательского интерфейса, но они создают почву для
роста - дальнейшего анализа и обсуждения.
В перспективе MVP могут генерироваться чуть ли не в процессе интервьюирования.
TODO:Может не существовать бойлеплейта для приложения (скажем, готовые сборки
Core/Infrastructure/Web). CLI может автоматически собирать классы, интерфейсы и
т.п. согласно conventions и добавлять их в соответствующие сборки (создавая при
отсутствии).
