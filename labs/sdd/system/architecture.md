# Architecture

## TODO:Рассуждения

Условно под архитектурой будет пониматься фундаментальная организация
строительных блоков и соединений. Из кирпичей, железобетонных блоков или иным
образом. Такая аналогия со строительство намекает на перспективы вынесения
некоторых идеё в общий инжиниринг.

Есть несколько самостоятельных направлений, которые зачастую рассматриваются
изолированно. 

### Абстрактные машины
* Иашина Тьюринга
* Нормальный алгоритм Маркова

### Способ достижения результата
* Декларативный подход. Что на сделать.
* Императивный подход. Как это надо сделать.

* Когда мы знаем, что надо сделать, может быть более одного ответа - как это
  можно сделать. А некоторых, более оптимальных способов реализации, мы можем
  ещё не знать. Поэтому, по крайней мере теоретически, декларативное
  программирование является предпочтительным. Для понимания этого можно
  использовать и ключевые инструменты императивного подхода. Мы создаем
  абстракцию, у которой может быть множество реализаций.
* Декларативный способ практически тождествен specs-oriented vision в SDD.

### Парадигмы программирования
* Объектно-ориентированная
* Функциональная
* Акторная (agent-oriented)
* Message-oriented

### Функциональное программирование
* Функцию можно рассматривать в императивном ключе, получая message-oriented
  программирование с серьёзными ограничениями. Функция - как однопоточный,
  синхронный обработчик сообщений.
* Функцию можно рассматривать и в декларативном ключе. Когда мы под ней скорее
  понимаем потребность в продукте и аргументы - это ресурсы. Скажем:
  createChair = (getMaterials, getTools); getMaterials = (getWood, getNails);
  Если эти функциональные зависимости вывести в виде дерева, то получится
  структура очень похожая на список задач. В данном случае мы говорим
  исключительно о том, что мы хотим получить. Каким образом продукты движутся
  по эти цепочкам не определено. Это может проактивная или реактивная
  реализация, синхронная или асинхронная.
* Актор/агент можно рассматривать как функцию. Как результат, message-oriented/
  agent-oriented архитектура может быть основана на функциях. Отличие только в
  том, как осуществляется диспетчеризация. То есть продукты одних функций
  отправляются на вход других.

### Message-oriented
* Подкупает органичность подхода. Он во многом похож на человеческие процессы.
* Есть пока только ощущение что подобная архитектура может очень эффективно
  использовать ресурсы. 
  * Переходы между обработчиками могут осуществляться через JMP, а не CALL.
    Менее активное использование стека. Компилятор может обеспечить эффективный
	роутинг между данными продукта, сохранёнными в регистрах и агрументами
	следующего обработчика в цепочке.
  * Log-based, actor-scoped аллокации.
  * Высокий уровень параллелизации "by design".
  * Возможность пакетной обработки однотипных операций или даже исключение
    некоторых (например, несколько операций по записи одной и той же страницы БД
	эквивалентны выполнению только последней операции).
* Пока под вопросом разница между actor-oriented и message-oriented. Возможно,
  последняя рассматривается скорее как стек коммуникационных решений (service
  bus, message queue, etc.).
* Интересно рассмотреть функциональные подходы через призму сообщений.
  Каррирование, композицию и т.п. Пример каррирования - скажем сообщение для
  расчёта некоторой финансовой транзакции может получать
  (amountInCurrency, exchangeRate, ...) а возвращать сообщение с
  (amountNormalized, ...).
* Этот подход может быть очень эффективным и гибким, что создает определённый
  риск. Насколько удобно и надёжно будет описывать в нём логику? Возможно, речь
  идет скорее об императивной части, которая может генерироваться из
  декларативных схем.
* Event sourcing легко организуется через message log. В целом, терминология,
  которая использует "message" мне импонирует больше, чем "event".
* Есть возможность давать приоритеты отдельно взятым операциям, что приближает
  к real-time системам.
* Есть интересное пересечение с ООП. Родоначальник данного подхода, Smalltalk,
  основывался как раз на отправке сообщений объекту.
