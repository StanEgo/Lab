Контейнеры IoC повсеместно используются для сервисов. А что насчёт сущностей?
Даже простой бизнес-объект часто имеет множество различных аспектов. Например,
классический Account/User - это комбинация персональной информации, реквизитов
для идентификации, уникальных ключей, факторов активности и истории, валидации,
установки значений по умолчанию, маппингов в базы данных, веб-формы и много
другого.

Обычно мы видим множество схожих классов (как Account, AccountDto,
InsertAccountRequest, UpdateAccountRequest, SignInRequest, AccountViewModel и
т.п.) с минимальными отличиями, большим количество инкапсулированной логики и
мета-атрибутов. Использовать повторно такие конструкции в других проектах близко
к неразрешимой задаче. Но что если активно применить SOLID и на этом поле?

Начать стоит с сегрегации интерфейсов (ISP). Например, выделим такие как IHasId{T},
IHasLifetime, ICredentials. Первым же преимуществом становится то, что их можно
повторно использовать как среди реализаций различных отражений класса Account,
так и для многих других сущностей. И прочувствовать это можно будет ещё на этапе
формирования ubiquitous language, спецификации и документации.

Дальше это преимущество будет только нарастать. Скажем, появится реализация
IValidator{IHasLifetime}, проверяющая, что
(Deleted == null || Created <= Deleted). Это условие также будет повторно
использоваться везде. За ним возникнет IPopulator{IHasLifetime}, который
будет устанавливать значение Created = ITimeService.Get() далеко не только
одному Account. Когда будет описываться альтернативная настройка для маппинга
IHasLifetime в базу данных, мы не будем связаны по рукам и ногам мета-атрибутами,
а просто зарегистрируем новый IEntitySettings{IHasLifetime}, который будет опять
же работать не только для Account.

Рука об руку с ISP идёт принцип SRP. Структурные интерфейсы мы изменяем только в
том случае, когда изменения задействуют состав или тип полей. За каждое
поведенческое изменение отвечает уже свой отдельный интерфейс.

Реализуя конечную систему мы просто комбинируем нужные интерфейсы так, как это
продиктовано условиями задачи и проводим дополнительную донастройку.

    public interface IAccount : IPersonName, ICredentials, ILifetime {
        ...
    }

    public class SecurityComposition : IComposition {
        ...
        context
            // Это расширение будет добавлять все интерфейсам IHasId<int>
            .Db<int>()
            // Это расширение установит IAccount для всех последующих операций.
            .Entity<IAccount>()
            // Это расширение добавит вызовы IPopulator<> + IValidator<>
            .Insert()
            .Update()
        ...
    }

Если вдруг выясняется, что у нас может быть множество ICredentials для
пользователя, мы вместо изменения целой цепочки классов и логики просто
переносим ICredentials в соответствующий класс плюс минимум изменений.

TODO: В идеале логику лучше базировать на выражениях (LINQ/Roslyn-based), чтобы
была возможность генерировать код для SQL, TypeScript, etc. Также это будет
полезно и для генерации классов. Скажем, если описан интерфейс валидации
IHasLifetime, его метод определён с использованием выражения, то мы можем
получить класс с инъекцией этого выражения в set-метод.

TODO: Пример важности вынесения логики на примере IPopulator/IDefault. Это
ужасно отлавливать вот такие реализации по всему коду и менять инициализации на
вызовы нужных сервисов (Created = ITimeService.Get()).

    var instance = new SomeEntity()
    {
        Id = Guid.New(),
        Created = DateTime.UtcNow,
        ...
    }

TODO: Генерация маппингом между родственными классами (AccountSample => SignInRequest).

TODO: Легче писать method extensions для таких маленьких интерфейсов.

TODO: Легче делать из одного экземпляра много и наборот. Скажем, в начале
хранили для персоны один IGeoAddress, а потом решили сделать много.

TODO: Повторное использование трансляций (переводов), поскольку они могут
задаваться для базовых интерфейсов.

TODO: Возможно ли обеспечить внутренние реализации интерфейсов через структуры?
Конфигурабельно.

TODO: Настройки сериализации/десериализации.

TODO: Можно привести пример замены генератора для IHasId{uint} на
SnowflakeIdGenerator.
